//
// Created by keltar on 10/8/17.
//

#ifndef TINY_C_COMPILER_TOKEN_H
#define TINY_C_COMPILER_TOKEN_H

#include <string>
#include <unordered_map>
#include <utility>

enum class TokenType
{
    ID, NUM_INT, NUM_FLOAT, LBRACKET, RBRACKET, LCURLY_BRACKET, RCURLY_BRACKET, LSQUARE_BRACKET, RSQUARE_BRACKER,
    SEMICOLON, COLON, DOT, QUESTION_MARK, COMMA, ASSIGNMENT, RELOP_EQ, RELOP_GT, RELOP_LT, RELOP_GE, RELOP_LE, RELOP_NE,
    LOGIC_NO, BITWISE_NOT, REMINDER, BITWISE_LSHIFT, BITWISE_RSHIFT, BITWISE_OR, BITWISE_XOR, BITWISE_AND,
    LOGIC_OR, LOGIC_AND, MINUS, PLUS, ASTERIX, DOUBLE_PLUS, DOUBLE_MINUS, ASSIGNMENT_BY_SUM, ASSIGNMENT_BY_DIFFERENCE,
    ASSIGNMENT_BY_PRODUCT, ASSIGNMENT_BY_QUOTIENT, ASSIGNMENT_BY_REMINDER, ASSIGNMENT_BY_BITWISE_OR,
    ASSIGNMENT_BY_BITWISE_XOR, ASSIGNMENT_BY_BITWISE_AND, ASSIGNMENT_BY_BITWISE_LSHIFT, ASSIGNMENT_BY_BITWISE_RSHIFT,
    BACK_SLASH, FORWARD_SLASH, ARROW, KEYWORD, CHARACTER, STRING
};

static std::unordered_map<TokenType, std::string> TokenTypeToString(
{
        {TokenType::ID, "ID"},{TokenType::NUM_INT, "NUM_INT"},{TokenType::NUM_FLOAT, "NUM_FLOAT"},
        {TokenType::LBRACKET, "LBRACKET"},{TokenType::RBRACKET, "RBRACKET"},
        {TokenType::LCURLY_BRACKET, "LCURLY_BRACKET"},{TokenType::RCURLY_BRACKET, "RCURLY_BRACKET"},
        {TokenType::LSQUARE_BRACKET, "LSQUARE_BRACKET"},{TokenType::RSQUARE_BRACKER, "RSQUARE_BRACKER"},
        {TokenType::SEMICOLON, "SEMICOLON"},{TokenType::COLON, "COLON"},{TokenType::DOT, "DOT"},
        {TokenType::QUESTION_MARK, "QUESTION_MARK"},{TokenType::COMMA, "COMMA"},{TokenType::ASSIGNMENT, "ASSIGNMENT"},
        {TokenType::RELOP_EQ, "RELOP_EQ"},{TokenType::RELOP_GT, "RELOP_GT"},{TokenType::RELOP_LT, "RELOP_LT"},
        {TokenType::RELOP_GE, "RELOP_GE"},{TokenType::RELOP_LE, "RELOP_LE"},{TokenType::RELOP_NE, "RELOP_NE"},
        {TokenType::LOGIC_NO, "LOGIC_NO"},{TokenType::BITWISE_NOT, "BITWISE_NOT"}, {TokenType::REMINDER, "REMINDER"},
        {TokenType::BITWISE_LSHIFT, "BITWISE_LSHIFT"}, {TokenType::BITWISE_RSHIFT, "BITWISE_RSHIFT"},
        {TokenType::BITWISE_AND, "BITWISE_AND"}, {TokenType::BITWISE_XOR, "BITWISE_XOR"},
        {TokenType::BITWISE_OR, "BITWISE_OR"}, {TokenType::LOGIC_AND, "LOGIC_AND"}, {TokenType::LOGIC_OR, "LOBIC_OR"},
        {TokenType::MINUS, "MINUS"}, {TokenType::PLUS, "PLUS"}, {TokenType::ASTERIX, "ASTERIX"},
        {TokenType::DOUBLE_PLUS, "DOUBLE_PLUS"}, {TokenType::DOUBLE_MINUS, "DOUBLE_MINUS"},
        {TokenType::ASSIGNMENT_BY_SUM, "ASSIGNMENT_BY_SUM"}, {TokenType::ASSIGNMENT_BY_DIFFERENCE, "ASSIGNMENT_BY_DIFFERENCE"},
        {TokenType::ASSIGNMENT_BY_PRODUCT, "ASSIGNMENT_BY_PRODUCT"}, {TokenType::ASSIGNMENT_BY_QUOTIENT, "ASSIGNMENT_BY_QUOTIENT"},
        {TokenType::ASSIGNMENT_BY_REMINDER, "ASSIGNMENT_BY_REMINDER"}, {TokenType::ARROW, "ARROW"},
        {TokenType::ASSIGNMENT_BY_BITWISE_AND, "ASSIGNMENT_BY_BITWISE_AND"}, {TokenType::CHARACTER, "CHARACTER"},
        {TokenType::ASSIGNMENT_BY_BITWISE_OR, "ASSIGNMENT_BY_BITWISE_OR"}, {TokenType::FORWARD_SLASH, "FORWARD_SLASH"},
        {TokenType::ASSIGNMENT_BY_BITWISE_XOR, "ASSIGNMENT_BY_BITWISE_XOR"}, {TokenType::STRING, "STRING"},
        {TokenType::ASSIGNMENT_BY_BITWISE_LSHIFT, "ASSIGNMENT_BY_BITWISE_LSHIFT"}, {TokenType::KEYWORD, "KEYWORD"},
        {TokenType::ASSIGNMENT_BY_BITWISE_RSHIFT, "ASSIGNMENT_BY_BITWISE_RSHIFT"}, {TokenType::BACK_SLASH, "BACK_SLASH"}
});

struct Token
{
    TokenType type;
    int row, col;
    std::string text;

    Token(TokenType type, int row, int col, std::string text): type(type), row(row), col(col), text(std::move(text)) {}
};

#endif //TINY_C_COMPILER_TOKEN_H
